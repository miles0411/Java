/* Generated by Together */
import java.util.*;
import java.text.*;

/** A container of GPTrees. */
public class Generation {
    private int numTrees;
    protected GPTree[] population;
    private Random rand = new Random();


    /** Specifies the number of GPTrees in this generation, the
    * factories used to generate the individual trees, the maximum tree depth,
    * and the Random object used. */
    Generation(int numTrees, OperatorFactory o, TerminalFactory t, int m, Random r) {
        this.numTrees = numTrees;
        population = new GPTree[numTrees];
        for (int i = 0; i < numTrees; i++)
            population[i] = new GPTree(o, t, m, r);
    }
    
    /** Evaluate each tree in this generation, and set each tree's fitness value. */
    
   public void evalAll(DataSet d) {
	   for (int i = 0; i < numTrees; i++){
        population[i].eval(d);       
	   }
    }

    /** Print the symbolicEval of each tree, and its fitness value. Very lengthy! */
    public void printAll() {
        for (int i = 0; i < numTrees; i++) {
            System.out.println(population[i]);
            System.out.println("This tree's fitness is "
                +  NumberFormat.getInstance().format(population[i].getFitness()));
        }
    }

    /** Prints the tree with the lowest fitness value. */
    public void printBestTree() {
        Arrays.sort(this.population);
        //printAll();
        System.out.println(population[0]);
        System.out.println("Its fitness is " + population[0].getFitness());
    }
    
    
    
    /**This is to choose the trees at a proportional possiblity according to tree fitness.
       USe getadjustedFitness method written by me to make the tree with lowerst fitness to be chosen.
       Then Calculate 1/fitness across the entire population.
       Use a random double to locate at the scale 0%~100% within the Totalfitness.
       Finally, start to check one by one until the cumulative supercede the locator, then that interval representing the tree will get chosen
       return the chosen tree proportionally random chosen*/
       public GPTree chooseTreeProportionalToFitness(DataSet d){		
       double totalFitness =0;										
 	   for(int i=0;i<population.length;i++){
       totalFitness += population[i].getadjustedFitness();			
 	   }
 	   double locator=totalFitness*rand.nextDouble();				
 	   double cumulative = 0;										
 	   int i=0;
 	   if(locator == 0){
 		   i++;
 	   }
 	   else{
 		  while(locator>cumulative){								
 			 cumulative += population[i].getadjustedFitness();
 			 i++;
 		  }
 	   }   
 	   
 	   GPTree chosen = population[i-1];
 	   return chosen;												
    }
}
