/* Generated by Together */
import java.util.*;
import java.text.*;

/** A container of GPTrees. */
public class Generation {
    private int numTrees;
    private GPTree[] population;
    private double[] fitness;
    private double[] normalizedInverseFitness;

    /** Specifies the number of GPTrees in this generation, the
    * factories used to generate the individual trees, the maximum tree depth,
    * and the Random object used. */
    Generation(int numTrees, OperatorFactory o, TerminalFactory t, int m, Random r) {
        this.numTrees = numTrees;
        population = new GPTree[numTrees];
        fitness = new double[numTrees];
        normalizedInverseFitness = new double[numTrees];
        for (int i = 0; i < numTrees; i++)
            population[i] = new GPTree(o, t, m, r);
    }
    Generation(int n) {
        numTrees = n;
        population = new GPTree[numTrees];
        fitness = new double[numTrees];
        normalizedInverseFitness = new double[numTrees];
    }


    /** Evaluate each tree in this generation, and set each tree's fitness value. */
    public void evalAll(DataSet theData) {
        double sumInverse = 0;
        //int numRows = theData.getNumRows();
        //int numXVals = theData.numXVals;
        for (int i = 0; i < numTrees; i++) {
            fitness[i] = population[i].eval(theData);
            normalizedInverseFitness[i] = 1 / fitness[i];
            sumInverse += normalizedInverseFitness[i];
        }
        for (int i = 0; i < numTrees; i++)
            normalizedInverseFitness[i] /= sumInverse;
    }

    /** Print the symbolicEval of each tree, and its fitness value. Very lengthy! */
    public void printAll() {
        for (int i = 0; i < numTrees; i++) {
            System.out.println(population[i]);
            System.out.println("This tree's fitness is "
                +  NumberFormat.getInstance().format(population[i].getFitness()));
        }
    }
    public void replaceTree(int i, GPTree t) {
        population[i] = t;
    }
    public GPTree getTree(int i) {
        return population[i];
    }
    public GPTree chooseTreeProportionalToFitness(Random rand) {
        double cutoff = rand.nextDouble();
        //System.out.println("chooseTreeProportionalToFitness:cutoff = " + cutoff);
        double sumSoFar = 0.0;
        int chosenTreeIndex = 0;
        for (int i = 0; (i < numTrees) && (sumSoFar < cutoff); i++) {
            sumSoFar += normalizedInverseFitness[i];
            chosenTreeIndex = i;
        }
        //System.out.println("Tree chosen is:");
        //population[chosenTreeIndex].symbolicEval();
        //System.out.println();
        //System.out.println("Tree index is " + chosenTreeIndex);
        return population[chosenTreeIndex];
    }

    public static void crossover(GPTree t1, GPTree t2, Random rand) {
        NodePairPlus pair1 = t1.randomParentAndChild(rand);
        NodePairPlus pair2 = t2.randomParentAndChild(rand);
        pair1.parent.changeChild(pair1.child, pair2.child);
        pair2.parent.changeChild(pair2.child, pair1.child);
    }

    /** Prints the tree with the lowest fitness value. 
     * @return */
    public String printBestTree() {
        Arrays.sort(population);
        //printAll();
        String result = null;
        result =  population[0].toString() + "\r\n" + "Its fitness is " + population[0].getFitness()+ "\r\n"+ "\r\n";
        return result;
    }
    public int getNumTrees() { return numTrees; }
    public void printGeneration() {
        for (int i = 0; i < numTrees; i++) {
            System.out.println(population[i]);
        }
    }
}
